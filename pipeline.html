

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Pipeline &mdash; Renard  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Extending Renard" href="extending.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Renard
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Pipeline</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pipeline-output-the-pipeline-state">Pipeline Output: the Pipeline State</a></li>
<li class="toctree-l2"><a class="reference internal" href="#available-steps-an-overview">Available Steps: An Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preprocessing">Preprocessing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tokenization">Tokenization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#named-entity-recognition">Named Entity Recognition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coreference-resolution">Coreference Resolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quote-detection">Quote Detection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sentiment-analysis">Sentiment Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#characters-extraction">Characters Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#speaker-attribution">Speaker Attribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graph-extraction">Graph Extraction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-graphs">Dynamic Graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#custom-segmentation">Custom Segmentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multilingual-support">Multilingual Support</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extending.html">Extending Renard</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Renard</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">The Pipeline</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/pipeline.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="the-pipeline">
<h1>The Pipeline<a class="headerlink" href="#the-pipeline" title="Link to this heading"></a></h1>
<p>Renard’s central concept is the <a class="reference internal" href="reference.html#renard.pipeline.core.Pipeline" title="renard.pipeline.core.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>. A
<a class="reference internal" href="reference.html#renard.pipeline.core.Pipeline" title="renard.pipeline.core.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> is a list of <a class="reference internal" href="reference.html#renard.pipeline.core.PipelineStep" title="renard.pipeline.core.PipelineStep"><code class="xref py py-class docutils literal notranslate"><span class="pre">PipelineStep</span></code></a> that are run
sequentially in order to extract a character graph from a
document. Here is a simple example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.tokenization</span><span class="w"> </span><span class="kn">import</span> <span class="n">NLTKTokenizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.ner</span><span class="w"> </span><span class="kn">import</span> <span class="n">NLTKNamedEntityRecognizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.character_unification</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphRulesCharacterUnifier</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.graph_extraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">CoOccurrencesGraphExtractor</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./my_doc.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">NLTKTokenizer</span><span class="p">(),</span>
        <span class="n">NLTKNamedEntityRecognizer</span><span class="p">(),</span>
        <span class="n">GraphRulesCharacterUnifier</span><span class="p">(</span><span class="n">min_appearances</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
        <span class="n">CoOccurrencesGraphExtractor</span><span class="p">(</span><span class="n">co_occurrences_dist</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>Each step of a pipeline may require information from previous steps
before running : therefore, it is possible to create intractable
pipelines when a step’s requirements are not satisfied. To
troubleshoot these issues more easily, a <a class="reference internal" href="reference.html#renard.pipeline.core.Pipeline" title="renard.pipeline.core.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> checks its
validity at run time, and throws an exception with an helpful message
in case it is intractable.</p>
<p>You can also specify the result of certains steps manually when
calling the pipeline if you already have those results or if you want
to compute them yourself:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.ner</span><span class="w"> </span><span class="kn">import</span> <span class="n">NLTKNamedEntityRecognizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.character_unification</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphRulesCharacterUnifier</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.graph_extraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">CoOccurrencesGraphExtractor</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./my_doc.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># note that this pipeline doesn&#39;t have any tokenizer</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">NLTKNamedEntityRecognizer</span><span class="p">(),</span>
        <span class="n">GraphRulesCharacterUnifier</span><span class="p">(</span><span class="n">min_appearances</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
        <span class="n">CoOccurrencesGraphExtractor</span><span class="p">(</span><span class="n">co_occurrences_dist</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="c1"># tokens are passed at call time</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tokens</span><span class="o">=</span><span class="n">my_tokenization_function</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
</pre></div>
</div>
<p>In that case, the <code class="docutils literal notranslate"><span class="pre">tokens</span></code> requirements is fulfilled at run time. If
you don’t pass the parameter, Renard will throw the following
exception:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="ne">ValueError</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;step 1 (NLTKNamedEntityRecognizer) has unsatisfied needs. needs: {&#39;tokens&#39;}. available: {&#39;text&#39;}). missing: {&#39;tokens&#39;}.&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>For simplicity, one can use one of the preconfigured pipelines:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.preconfigured</span><span class="w"> </span><span class="kn">import</span> <span class="n">bert_pipeline</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./my_doc.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">bert_pipeline</span><span class="p">(</span>
    <span class="n">graph_extractor_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;co_occurrences_dist&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;sentences&quot;</span><span class="p">)}</span>
<span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<section id="pipeline-output-the-pipeline-state">
<h2>Pipeline Output: the Pipeline State<a class="headerlink" href="#pipeline-output-the-pipeline-state" title="Link to this heading"></a></h2>
<p>The <a class="reference internal" href="reference.html#renard.pipeline.core.PipelineState" title="renard.pipeline.core.PipelineState"><code class="xref py py-class docutils literal notranslate"><span class="pre">PipelineState</span></code></a> represents a state that is propagated and
annotated during the execution of a <a class="reference internal" href="reference.html#renard.pipeline.core.Pipeline" title="renard.pipeline.core.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>. It is the
final value returned when running a pipeline with
<a class="reference internal" href="reference.html#renard.pipeline.core.Pipeline.__call__" title="renard.pipeline.core.Pipeline.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Pipeline.__call__()</span></code></a>. As such, one can use it to do different
things. For example, one can access the extracted character network as
a networkx graph:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">character_network</span>
<span class="go">&lt;networkx.classes.graph.Graph object at 0x7fd9e9115900&gt;</span>
</pre></div>
</div>
<p>one can also access the output of each <a class="reference internal" href="reference.html#renard.pipeline.core.PipelineStep" title="renard.pipeline.core.PipelineStep"><code class="xref py py-class docutils literal notranslate"><span class="pre">PipelineStep</span></code></a>.</p>
<p>A few matplotlib-based plot functions are provided for convenience
(<a class="reference internal" href="reference.html#renard.pipeline.core.PipelineState.plot_graph" title="renard.pipeline.core.PipelineState.plot_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PipelineState.plot_graph()</span></code></a>,
<a class="reference internal" href="reference.html#renard.pipeline.core.PipelineState.plot_graph_to_file" title="renard.pipeline.core.PipelineState.plot_graph_to_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PipelineState.plot_graph_to_file()</span></code></a>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>These functions should be seen more as exploration and debug tools
rather than fully-fledged visualisation platforms. If you want a
fully-featured visualisation tool, you can export your graph to
Gephi’s <cite>gexf</cite> format:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">export_graph_to_gexf</span><span class="p">(</span><span class="s2">&quot;./graph.gexf&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="available-steps-an-overview">
<h2>Available Steps: An Overview<a class="headerlink" href="#available-steps-an-overview" title="Link to this heading"></a></h2>
<p>Below is an overview of the different steps that can make up a
pipeline. Note that <a class="reference internal" href="reference.html#renard.pipeline.stanford_corenlp.StanfordCoreNLPPipeline" title="renard.pipeline.stanford_corenlp.StanfordCoreNLPPipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">StanfordCoreNLPPipeline</span></code></a> is a special
case and regroup several steps as the same time.</p>
<section id="preprocessing">
<h3>Preprocessing<a class="headerlink" href="#preprocessing" title="Link to this heading"></a></h3>
<p><a class="reference internal" href="reference.html#renard.pipeline.preprocessing.CustomSubstitutionPreprocessor" title="renard.pipeline.preprocessing.CustomSubstitutionPreprocessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">CustomSubstitutionPreprocessor</span></code></a> allows to make regex-based
substitutions in the text.</p>
</section>
<section id="tokenization">
<h3>Tokenization<a class="headerlink" href="#tokenization" title="Link to this heading"></a></h3>
<p>Tokenization is the task of cutting text in <em>tokens</em>. It is usually
the first task to apply to a text. 2 tokenizer are available:</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#renard.pipeline.tokenization.NLTKTokenizer" title="renard.pipeline.tokenization.NLTKTokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NLTKTokenizer</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#renard.pipeline.stanford_corenlp.StanfordCoreNLPPipeline" title="renard.pipeline.stanford_corenlp.StanfordCoreNLPPipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">StanfordCoreNLPPipeline</span></code></a> does contain a tokenizer as part
of its full NLP pipeline.</p></li>
</ul>
</section>
<section id="named-entity-recognition">
<h3>Named Entity Recognition<a class="headerlink" href="#named-entity-recognition" title="Link to this heading"></a></h3>
<p>Named entity recognition (NER) detects entities occurences in the
text. 3 modules are available:</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#renard.pipeline.ner.NLTKNamedEntityRecognizer" title="renard.pipeline.ner.NLTKNamedEntityRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NLTKNamedEntityRecognizer</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#renard.pipeline.ner.BertNamedEntityRecognizer" title="renard.pipeline.ner.BertNamedEntityRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BertNamedEntityRecognizer</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#renard.pipeline.stanford_corenlp.StanfordCoreNLPPipeline" title="renard.pipeline.stanford_corenlp.StanfordCoreNLPPipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">StanfordCoreNLPPipeline</span></code></a> contains a NER model as part of
its full NLP pipeline.</p></li>
</ul>
</section>
<section id="coreference-resolution">
<h3>Coreference Resolution<a class="headerlink" href="#coreference-resolution" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#renard.pipeline.corefs.SpacyCorefereeCoreferenceResolver" title="renard.pipeline.corefs.SpacyCorefereeCoreferenceResolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpacyCorefereeCoreferenceResolver</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#renard.pipeline.corefs.BertCoreferenceResolver" title="renard.pipeline.corefs.BertCoreferenceResolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">BertCoreferenceResolver</span></code></a>, using the Tibert library.</p></li>
<li><p><a class="reference internal" href="reference.html#renard.pipeline.stanford_corenlp.StanfordCoreNLPPipeline" title="renard.pipeline.stanford_corenlp.StanfordCoreNLPPipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">StanfordCoreNLPPipeline</span></code></a> can execute a coreference
resolution model as part of its pipeline.</p></li>
</ul>
</section>
<section id="quote-detection">
<h3>Quote Detection<a class="headerlink" href="#quote-detection" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#renard.pipeline.quote_detection.QuoteDetector" title="renard.pipeline.quote_detection.QuoteDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuoteDetector</span></code></a></p></li>
</ul>
</section>
<section id="sentiment-analysis">
<h3>Sentiment Analysis<a class="headerlink" href="#sentiment-analysis" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#renard.pipeline.sentiment_analysis.NLTKSentimentAnalyzer" title="renard.pipeline.sentiment_analysis.NLTKSentimentAnalyzer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NLTKSentimentAnalyzer</span></code></a> leverages NLTK’s Vader for sentiment
analysis</p></li>
</ul>
</section>
<section id="characters-extraction">
<h3>Characters Extraction<a class="headerlink" href="#characters-extraction" title="Link to this heading"></a></h3>
<p>Characters extraction (or alias resolution) extract characters from
occurences detected using NER. This is done by assigning each mention
to a unique character.</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#renard.pipeline.character_unification.NaiveCharacterUnifier" title="renard.pipeline.character_unification.NaiveCharacterUnifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">NaiveCharacterUnifier</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#renard.pipeline.character_unification.GraphRulesCharacterUnifier" title="renard.pipeline.character_unification.GraphRulesCharacterUnifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphRulesCharacterUnifier</span></code></a></p></li>
</ul>
</section>
<section id="speaker-attribution">
<h3>Speaker Attribution<a class="headerlink" href="#speaker-attribution" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#renard.pipeline.speaker_attribution.BertSpeakerDetector" title="renard.pipeline.speaker_attribution.BertSpeakerDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">BertSpeakerDetector</span></code></a></p></li>
</ul>
</section>
<section id="graph-extraction">
<h3>Graph Extraction<a class="headerlink" href="#graph-extraction" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#renard.pipeline.graph_extraction.CoOccurrencesGraphExtractor" title="renard.pipeline.graph_extraction.CoOccurrencesGraphExtractor"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoOccurrencesGraphExtractor</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#renard.pipeline.graph_extraction.ConversationalGraphExtractor" title="renard.pipeline.graph_extraction.ConversationalGraphExtractor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConversationalGraphExtractor</span></code></a></p></li>
</ul>
</section>
</section>
<section id="dynamic-graphs">
<h2>Dynamic Graphs<a class="headerlink" href="#dynamic-graphs" title="Link to this heading"></a></h2>
<p>Renard can also extract <em>dynamic graphs</em>: graphs that evolve through
time. In Renard, such graphs are representend by a <code class="docutils literal notranslate"><span class="pre">List</span></code> of
<code class="docutils literal notranslate"><span class="pre">networkx.Graph</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.tokenization</span><span class="w"> </span><span class="kn">import</span> <span class="n">NLTKTokenizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.ner</span><span class="w"> </span><span class="kn">import</span> <span class="n">NLTKNamedEntityRecognizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.character_unification</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphRulesCharacterUnifier</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.graph_extraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">CoOccurrencesGraphExtractor</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./my_doc.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">NLTKTokenizer</span><span class="p">(),</span>
        <span class="n">NLTKNamedEntityRecognizer</span><span class="p">(),</span>
        <span class="n">GraphRulesCharacterUnifier</span><span class="p">(</span><span class="n">min_appearances</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
        <span class="n">CoOccurrencesGraphExtractor</span><span class="p">(</span>
            <span class="n">co_occurrences_dist</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
            <span class="n">dynamic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>     <span class="c1"># note the &#39;dynamic&#39;</span>
            <span class="n">dynamic_window</span><span class="o">=</span><span class="mi">20</span> <span class="c1"># and the &#39;dynamic_window&#39; argument</span>
        <span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>When executing the above block of code, the output attribute
<code class="docutils literal notranslate"><span class="pre">character_network</span></code> will be a list of networkx graphs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">character_network</span>
<span class="go">[&lt;networkx.classes.graph.Graph object at 0x7fd9e9115900&gt;]</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="reference.html#renard.pipeline.graph_extraction.CoOccurrencesGraphExtractor" title="renard.pipeline.graph_extraction.CoOccurrencesGraphExtractor"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoOccurrencesGraphExtractor</span></code></a> for more details on the
usage of the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> and <code class="docutils literal notranslate"><span class="pre">dynamic_window</span></code> arguments.</p>
<p>Plot and export functions work as one would expect
intuitively. <a class="reference internal" href="reference.html#renard.pipeline.core.PipelineState.plot_graph" title="renard.pipeline.core.PipelineState.plot_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PipelineState.plot_graph()</span></code></a> allow to visualize the
dynamic graph using a slider, and
<a class="reference internal" href="reference.html#renard.pipeline.core.PipelineState.plot_graphs_to_dir" title="renard.pipeline.core.PipelineState.plot_graphs_to_dir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PipelineState.plot_graphs_to_dir()</span></code></a> saves plots of the dynamic
graph to a directory. Meanwhile,
<a class="reference internal" href="reference.html#renard.pipeline.core.PipelineState.export_graph_to_gexf" title="renard.pipeline.core.PipelineState.export_graph_to_gexf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PipelineState.export_graph_to_gexf()</span></code></a> correctly exports the
dynamic graph to the Gephi format.</p>
<section id="custom-segmentation">
<h3>Custom Segmentation<a class="headerlink" href="#custom-segmentation" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">dynamic_window</span></code> parameter of
<code class="xref py py-class docutils literal notranslate"><span class="pre">CoOccurencesGraphExtractor</span></code> determines the segmentation of
the dynamic networks, in number of interactions. In the example above,
a new graph will be created for each 20 interactions.</p>
<p>While one can rely on the arguments of the graph extractor of the
pipeline to determine the dynamic window, Renard allows to specify a
custom segmentation of a text with the <code class="docutils literal notranslate"><span class="pre">dynamic_blocks</span></code>
argument. When running a pipeline, you can cut your text however you
want and pass this argument instead of the usual text:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.tokenization</span><span class="w"> </span><span class="kn">import</span> <span class="n">NLTKTokenizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.ner</span><span class="w"> </span><span class="kn">import</span> <span class="n">NLTKNamedEntityRecognizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.character_unification</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphRulesCharacterUnifier</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.graph_extraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">CoOccurrencesGraphExtractor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">block_bounds</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./my_doc.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># let&#39;s suppose the &#39;cut_into_chapters&#39; function cut the text into chapters.</span>
<span class="n">chapters</span> <span class="o">=</span> <span class="n">cut_into_chapters</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">NLTKTokenizer</span><span class="p">(),</span>
        <span class="n">NLTKNamedEntityRecognizer</span><span class="p">(),</span>
        <span class="n">GraphRulesCharacterUnifier</span><span class="p">(),</span>
        <span class="n">CoOccurrencesGraphExtractor</span><span class="p">(</span><span class="n">co_occurrences_dist</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="c1"># the &#39;block_bounds&#39; function automatically extracts the boundaries of your</span>
<span class="c1"># block of text.</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">dynamic_blocks</span><span class="o">=</span><span class="n">block_bounds</span><span class="p">(</span><span class="n">chapters</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>
<section id="multilingual-support">
<h2>Multilingual Support<a class="headerlink" href="#multilingual-support" title="Link to this heading"></a></h2>
<p>Renard supports multiple languages. By default, a <a class="reference internal" href="reference.html#renard.pipeline.core.Pipeline" title="renard.pipeline.core.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>
is configured for English, but can create a pipeline for any language
<em>as long as all of its steps support it</em>. To configure a pipeline for
another language, you can pass the ISO 639-3 code of the language you
want:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.tokenization</span><span class="w"> </span><span class="kn">import</span> <span class="n">NLTKTokenizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.ner</span><span class="w"> </span><span class="kn">import</span> <span class="n">BertNamedEntityRecognizer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.character_unification</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphRulesCharacterUnifier</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">renard.pipeline.graph_extraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">CoOccurrencesGraphExtractor</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./my_doc_in_french.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">NLTKTokenizer</span><span class="p">(),</span>
        <span class="n">BertNamedEntityRecognizer</span><span class="p">(),</span>
        <span class="n">GraphRulesCharacterUnifier</span><span class="p">(</span><span class="n">min_appearances</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
        <span class="n">CoOccurrencesGraphExtractor</span><span class="p">(</span><span class="n">co_occurrences_dist</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
    <span class="p">],</span>
    <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;fra&quot;</span> <span class="c1"># ISO 639-3 language code for french</span>
<span class="p">)</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>This pipeline is valid because <a class="reference internal" href="reference.html#renard.pipeline.tokenization.NLTKTokenizer" title="renard.pipeline.tokenization.NLTKTokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NLTKTokenizer</span></code></a>,
<a class="reference internal" href="reference.html#renard.pipeline.ner.BertNamedEntityRecognizer" title="renard.pipeline.ner.BertNamedEntityRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BertNamedEntityRecognizer</span></code></a> and
<a class="reference internal" href="reference.html#renard.pipeline.character_unification.GraphRulesCharacterUnifier" title="renard.pipeline.character_unification.GraphRulesCharacterUnifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphRulesCharacterUnifier</span></code></a> all support french, and that
<code class="xref py py-class docutils literal notranslate"><span class="pre">CoOccurencesGraphExtractor</span></code> works for any language. If that
pipeline was invalid, Renard would display an error message explaining
why. Renard can perform this language check because each step
explicitely indicates which languages it supports by overriding the
<a class="reference internal" href="reference.html#renard.pipeline.core.PipelineStep.supported_langs" title="renard.pipeline.core.PipelineStep.supported_langs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PipelineStep.supported_langs()</span></code></a> method. This method returns the
sets of languages supported by a step as ISO 639-3 codes. The special
string <code class="docutils literal notranslate"><span class="pre">&quot;any&quot;</span></code> is used to indicate that the step works regardless of
language. If the method is not overrided, the default is english
support only.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="extending.html" class="btn btn-neutral float-right" title="Extending Renard" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Arthur Amalvy, Vincent Labatut, Richard Dufour.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>